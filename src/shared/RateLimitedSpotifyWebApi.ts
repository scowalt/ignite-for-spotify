import { SpotifyWebApi } from "spotify-web-api-ts";
import PromiseQueue from "p-queue";
import { Logger } from "./Logger";
import { Song } from "../db/models/Song";
import { Query } from "./Query";
import { promisify } from 'util';
import { Paging, Track, PrivateUser, Playlist } from "spotify-web-api-ts/types/types/SpotifyObjects";

const wait: (ms: number) => Promise<void> = promisify(setTimeout);

enum Priority {
	UserTask = 3,
	PlaylistUpdate = 2,
	SpotifyUpdate = 0,
}

export class RateLimitedSpotifyWebApi {
	public static async createInstance(accessToken: string, refreshToken: string): Promise<RateLimitedSpotifyWebApi> {
		const instance: RateLimitedSpotifyWebApi = new RateLimitedSpotifyWebApi(accessToken, refreshToken);
		await instance.init();
		return instance;
	}

	private readonly spotify: SpotifyWebApi;
	private readonly refreshToken: string;
	private static readonly queue: PromiseQueue = new PromiseQueue({
		concurrency: 5,
		interval: 1 * 1000, // one second
		// Spotify doesn't prescribe how many requests are allowed per second. In my testing, I've found that 10/s is too many.
		intervalCap: 7
	});;

	private constructor(accessToken: string, refreshToken: string) {
		this.spotify = new SpotifyWebApi({
			clientId: process.env.SPOTIFY_CLIENT_ID,
			clientSecret: process.env.SPOTIFY_CLIENT_SECRET,
		});
		this.spotify.setAccessToken(accessToken);
		this.refreshToken = refreshToken;
	}

	public searchTracks(searchQuery: Query): Promise<Track[]> {
		Logger.getInstance().debug(`RateLimitedSpotifyWebApi.serachTracks("${searchQuery.toString()}") [Queue pending promises: ${RateLimitedSpotifyWebApi.queue.pending}]`);
		return this.enqueue(() => {
			Logger.getInstance().debug(`Calling this.spotify.searchTracks("${searchQuery.toString()}")`);
			return this.spotify.search.searchTracks(searchQuery.toString()).then((value: Paging<Track>) => {
				Logger.getInstance().debug(`this.spotify.searchTracks("${searchQuery}") SUCCEEDED`);
				return Promise.resolve(value.items);
			});
		}, Priority.SpotifyUpdate).catch((error: Error) => {
			Logger.getInstance().error(`this.spotify.searchTracks("${searchQuery.toString()}") failed with error ${error}`);
			return Promise.reject(error);
		});
	}

	// Create a playlist for the "entire-library constantly-updated" feature
	public async createEntireLibraryPlaylist(id: number): Promise<string> {
		const userProfile: PrivateUser = await this.getMe();
		const createPlaylistResponse: Playlist = await this.enqueue(() => {
			return this.spotify.playlists.createPlaylist(userProfile.id, `Rocksmith (C)DLC (part ${id}/?)`, {
				public: false, // Start the playlist private, manually make public later
				collaborative: false,
				description: `Rocksmith and Rocksmith 2014 DLC and CDLC. Mirrors the database found at CustomsForge Ignition. More info at https://ignite-for-spotify.scowalt.com/`
			});
		}, Priority.PlaylistUpdate);
		return createPlaylistResponse.id;
	}

	// Create a playlist for a user
	public createPlaylist(userId: string, playlistName: string): Promise<Playlist> {
		return this.enqueue(() => {
			return this.spotify.playlists.createPlaylist(userId, playlistName, {
				public: false,
				collaborative: false,
				description: `Generated by Ignite for Spotify (https://ignite-for-spotify.scowalt.com/)`
			});
		}, Priority.UserTask);
	}

	public addTracksToPlaylist(playlistId: string, tracks: string[]): Promise<string> {
		return this.enqueue(() => {
			return this.spotify.playlists.addItemsToPlaylist(playlistId, tracks);
		}, Priority.UserTask);
	}

	public async addSongsToPlaylist(playlistId: string, songs: Song[], position: number): Promise<string> {
		return this.enqueue(() => {
			return this.spotify.playlists.addItemsToPlaylist(playlistId, songs.map((song: Song) => { return `spotify:track:${song.spotifyTrackId}`; }), { position });
		}, Priority.PlaylistUpdate);
	}

	public async removePlaylistTracksAtPosition(playlistId: string, playlistOffset: number, count: number): Promise<Playlist|string> {
		return this.enqueue(async () => {
			const playlistResponse: Playlist = await this.spotify.playlists.getPlaylist(playlistId);
			const items: { uri: string; positions: number[] }[] = [];
			const limit: number = Math.min(playlistOffset + count, playlistResponse.tracks.total);
			let index: number = 0;
			for (let position: number = playlistOffset; position < limit; position++) {
				items.push({
					uri: playlistResponse.tracks.items[index].track.uri,
					positions: [position],
				});
				index++;
			}
			if (items.length !== 0) {
				return this.spotify.playlists.removePlaylistItemsByPosition(playlistId, items);
			} else {
				return Promise.resolve(playlistResponse);
			}
		}, Priority.PlaylistUpdate).catch((reason: any) => {
			Logger.getInstance().error(`Spotify API error ${reason.toString()}`);
			Logger.getInstance().error(`Failure at removePlaylistTracksAtPosition("${playlistId}", ${playlistOffset}, ${count})`);
			return Promise.reject(reason);
		});
	}

	private init(): Promise<any> {
		return this.updateAccessToken();
	}

	public async updateAccessToken(): Promise<void> {
		const value = await this.spotify.getRefreshedAccessToken(this.refreshToken);
		this.spotify.setAccessToken(value.access_token);
	}

	public getMe(): Promise<PrivateUser> {
		return this.enqueue(() => {
			return this.spotify.users.getMe();
		}, Priority.UserTask);
	}

	private enqueue<T>(task: () => Promise<T>, priority: Priority): Promise<T> {
		return RateLimitedSpotifyWebApi.queue.add(task, {
			priority
		}).catch((error: Error) => {
			let restartCondition: Promise<void>|undefined;
			if (error.message.includes("401")) {
				// This action likely failed because the access token expired. Pause execution of tasks in the queue while
				// the auth token updates to avoid other failures. Retry this task, since it likely only failed due to the
				// expired token, and return the new result;
				restartCondition = this.updateAccessToken();
			} else if (error.message.includes("429")) {
				Logger.getInstance().warn(`Spotify API error 429: Too many requests`);

				// The Spotify API returns a "Retry-After" header that prescribes the exact amount of time that should pass before more requests are sent.
				// Unfortunately, this information isn't exposed by the spotify api wrapper. So, for now, just wait a constant amount of seconds.
				// See https://stackoverflow.com/a/30557896/1222411
				restartCondition = wait(4 * 1000);
			} else {
				// TODO Retry requests that give a 500 error. There seems to be some flakiness in the Spotify APIs
				Logger.getInstance().error(`Unrecognized Spotify API error ${JSON.stringify(error)}`);
			}

			if (restartCondition) {
				RateLimitedSpotifyWebApi.queue.pause();
				return restartCondition.then(() => {
					RateLimitedSpotifyWebApi.queue.start();
					return task();
				});
			}

			// If the failure was anything else, no need to catch it here.
			return Promise.reject(error);
		});
	}
}
