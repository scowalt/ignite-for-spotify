import SpotifyWebApi, { RefreshAccessTokenResponse } from "spotify-web-api-node";
import PromiseQueue from "p-queue";
import { Logger } from "./Logger";
import { Song } from "../db/models/Song";
import { Query } from "./Query";
import { promisify } from 'util';

const wait: (ms: number) => Promise<void> = promisify(setTimeout);

enum Priority {
	UserTask = 3,
	PlaylistUpdate = 2,
	SpotifyUpdate = 0,
}

export class RateLimitedSpotifyWebApi {
	public static async createInstance(accessToken: string, refreshToken: string, redirectUri: string): Promise<RateLimitedSpotifyWebApi> {
		const instance: RateLimitedSpotifyWebApi = new RateLimitedSpotifyWebApi(accessToken, refreshToken, redirectUri);
		await instance.init();
		return instance;
	}

	private readonly spotify: SpotifyWebApi;
	private static readonly queue: PromiseQueue = new PromiseQueue({
		concurrency: 5,
		interval: 1 * 1000, // one second
		// Spotify doesn't prescribe how many requests are allowed per second. In my testing, I've found that 10/s is too many.
		intervalCap: 7
	});

	private constructor(accessToken: string, refreshToken: string, redirectUri: string) {
		this.spotify = new SpotifyWebApi({
			clientId: process.env.SPOTIFY_CLIENT_ID,
			clientSecret: process.env.SPOTIFY_CLIENT_SECRET,
			redirectUri
		});
		this.spotify.setAccessToken(accessToken);
		this.spotify.setRefreshToken(refreshToken);
	}

	public searchTracks(searchQuery: Query): Promise<SpotifyApi.PagingObject<SpotifyApi.TrackObjectFull> | undefined> {
		Logger.getInstance().debug(`RateLimitedSpotifyWebApi.serachTracks("${searchQuery.toString()}") [Queue pending promises: ${RateLimitedSpotifyWebApi.queue.pending}]`);
		return this.enqueue(() => {
			Logger.getInstance().debug(`Calling this.spotify.searchTracks("${searchQuery.toString()}")`);
			return this.spotify.searchTracks(searchQuery.toString()).then((value: SpotifyWebApi.Response<SpotifyApi.SearchResponse>) => {
				Logger.getInstance().debug(`this.spotify.searchTracks("${searchQuery.toString()}") SUCCEEDED`);
				return Promise.resolve(value.body.tracks);
			});
		}, Priority.SpotifyUpdate);
	}

	// Create a playlist for the "entire-library constantly-updated" feature
	public async createEntireLibraryPlaylist(id: number): Promise<string> {
		const userProfile: SpotifyWebApi.Response<SpotifyApi.CurrentUsersProfileResponse> = await this.getMe();
		const createPlaylistResponse: SpotifyWebApi.Response<SpotifyApi.CreatePlaylistResponse> = await this.enqueue(() => {
			return this.spotify.createPlaylist(userProfile.body.id, `Rocksmith (C)DLC (part ${id}/?)`, {
				public: false, // Start the playlist private, manually make public later
				collaborative: false,
				description: `Rocksmith and Rocksmith 2014 DLC and CDLC. Mirrors the database found at CustomsForge Ignition. More info at https://ignite-for-spotify.scowalt.com/`
			});
		}, Priority.PlaylistUpdate);
		return createPlaylistResponse.body.id;
	}

	// Create a playlist for a user
	public createPlaylist(userId: string, playlistName: string): Promise<SpotifyWebApi.Response<SpotifyApi.CreatePlaylistResponse>> {
		return this.enqueue(() => {
			return this.spotify.createPlaylist(userId, playlistName, {
				public: false,
				collaborative: false,
				description: `Generated by Ignite for Spotify (https://ignite-for-spotify.scowalt.com/)`
			});
		}, Priority.UserTask);
	}

	public addTracksToPlaylist(playlistId: string, tracks: string[]): Promise<SpotifyWebApi.Response<SpotifyApi.AddTracksToPlaylistResponse>> {
		return this.enqueue(() => {
			return this.spotify.addTracksToPlaylist(playlistId, tracks);
		}, Priority.UserTask);
	}

	public async addSongsToPlaylist(playlistId: string, songs: Song[], position: number): Promise<SpotifyWebApi.Response<SpotifyApi.AddTracksToPlaylistResponse>> {
		return this.enqueue(() => {
			return this.spotify.addTracksToPlaylist(playlistId, songs.map((song: Song) => { return `spotify:track:${song.spotifyTrackId}`; }), { position });
		}, Priority.PlaylistUpdate);
	}

	public async removePlaylistTracksAtPosition(playlistId: string, playlistOffset: number, count: number): Promise<SpotifyWebApi.Response<SpotifyApi.RemoveTracksFromPlaylistResponse>> {
		return this.enqueue(async () => {
			const playlistResponse: SpotifyWebApi.Response<SpotifyApi.SinglePlaylistResponse> = await this.spotify.getPlaylist(playlistId);
			const positions: number[] = [];
			const limit: number = Math.min(playlistOffset + count, playlistResponse.body.tracks.total);
			for (let position: number = playlistOffset; position < limit; position++) {
				positions.push(position);
			}
			if (positions.length !== 0) {
				return this.spotify.removeTracksFromPlaylistByPosition(playlistId, positions, playlistResponse.body.snapshot_id);
			} else {
				return Promise.resolve(playlistResponse);
			}
		}, Priority.PlaylistUpdate).catch((reason: Error) => {
			Logger.getInstance().error(`Spotify API error ${reason.toString()}`);
			Logger.getInstance().error(`Failure at removePlaylistTracksAtPosition("${playlistId}", ${playlistOffset}, ${count})`);
			return Promise.reject(reason);
		});
	}

	private init(): Promise<any> {
		return this.updateAccessToken();
	}

	public updateAccessToken(): Promise<void> {
		return this.spotify.refreshAccessToken().then((value: SpotifyWebApi.Response<RefreshAccessTokenResponse>) => {
			this.spotify.setAccessToken(value.body.access_token);
			return Promise.resolve();
		});
	}

	public getMe(): Promise<SpotifyWebApi.Response<SpotifyApi.CurrentUsersProfileResponse>> {
		return this.enqueue(() => {
			return this.spotify.getMe();
		}, Priority.UserTask);
	}

	private enqueue<T>(task: () => Promise<T>, priority: Priority): Promise<T> {
		return RateLimitedSpotifyWebApi.queue.add(task, {
			priority
		}).catch((reason: any) => {
			let restartCondition: Promise<void>|undefined;
			if (reason && reason.name === "WebapiError" && reason.statusCode === 401 && reason.message === "Unauthorized") {
				// This action likely failed because the access token expired. Pause execution of tasks in the queue while
				// the auth token updates to avoid other failures. Retry this task, since it likely only failed due to the
				// expired token, and return the new result;
				restartCondition = this.updateAccessToken();
			} else if (reason && reason.name === `WebapiError` && reason.statusCode === 429 && reason.message === "Too Many Requests") {
				Logger.getInstance().warn(`Spotify API error 429: Too many requests`);

				// The Spotify API returns a "Retry-After" header that prescribes the exact amount of time that should pass before more requests are sent.
				// Unfortunately, this information isn't exposed by the spotify api wrapper. So, for now, just wait a constant amount of seconds.
				// See https://stackoverflow.com/a/30557896/1222411
				restartCondition = wait(4 * 1000);
			} else {
				// TODO Retry requests that give a 500 error. There seems to be some flakiness in the Spotify APIs
				Logger.getInstance().error(`Unrecognized Spotify API error ${JSON.stringify(reason)}`);
			}

			if (restartCondition) {
				RateLimitedSpotifyWebApi.queue.pause();
				return restartCondition.then(() => {
					RateLimitedSpotifyWebApi.queue.start();
					return task();
				});
			}

			// If the failure was anything else, no need to catch it here.
			return Promise.reject(reason);
		});
	}
}
